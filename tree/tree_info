一、二叉树
1. 二叉查找树（Binary Search Tree）
(1) 基本概念
   它的其它名称也叫BST，排序二叉树、有序二叉树、二叉搜索树.
   是一种排序好的树结构，具体定义为:
   a> 如果任意节点的左子树不为空，则左子树上的所有数据均小于根节点上的树；
   b> 如果任意节点的右子树不为空，则右子树上的所有数据均大于根节点上的树；
   c> 任意左、右子数也为二叉查找数；
   d> 没有键值相等的节点。
   
   二叉树的优势是查找、插入效率较高，其对应的时间复杂度为O(log2n)，最坏的情况(数据有序时)为O(n)。
   
（2）算法
   a> 查找
      若b是空树，则搜索失败，否则：
      若查找对象x的值等于根上的值，查找成功，否则：
      若查找对象x的值小于根上的值，则搜索左子树，否则：
      查找右子树。
      
   b> 插入
      若树为空，则插入值x为根节点，否则：
      若插入的值x等于根节点，则返回，否则：
      如插入的值x小于根节点，则插入到左子树，否则
      插入到右子树中。
      
   c> 删除
      若删除的值x为叶子节点，则直接删除，并将父节点指向的它的指针删除（不破坏树的结构）；
      若删除的值x只有左子树或右子树，则将值的对应的父节点指针指向x值的左子树或者右子树（不破坏树的结构）；
      若删除的值x左右子树都存在，则将x值的父指针指向x的左子树，同时找到x左子树中最后一个右叶子节点，并将x的右子树指向此叶子节点。
2. 笛卡尔树

二、平衡二叉树

三、B树
1.B-树(B-tree)
 （1）基本概念
    B-tree也是我们常说的B树，是一种自平衡树，能够保持数据有序，且查询、插入、删除的时间复杂度都为O(log2n),它可以拥有多余2个子树
    数目，在相同数目的情况下，这种设计可以缩短树的深度，减少读写目标数据的时间，常应用于数据库和文件系统中。
    一颗M阶的B树，它有如下特性：
    a> 树中每一个节点最多含有M个孩子（M>=2)；
    b> B树中每一个内部节点都会包含一定数量的键值，键值选定在d和2d数量之间；
    c> B树会约束所有的叶子节点在一个树的深度上。
 （2）算法
    前提，以一颗高度为h的M阶B树为例。
    a> 插入操作
       插入一个元素时，首先在B树中是否存在，如果不存在，一般在叶子结点中插入该新的元素，此时分3种情况：
       如果叶子结点空间足够，即该结点的关键字数小于m-1，则直接插入在叶子结点的左边或右边；
       如果空间满了以致没有足够的空间去添加新的元素，即该结点的关键字数已经有了m个，则需要将该结点进行“分裂”，将一半数量的关键字元素分裂到新的其相邻右结点中，中间关键字元素上移到父结点中，而且当结点中关键元素向右移动了，相关的指针也需要向右移。
       此外，如果在上述中间关键字上移到父结点的过程中，导致根结点空间满了，那么根结点也要进行分裂操作，这样原来的根结点中的中间关键字元素向上移动到新的根结点中，因此导致树的高度增加一层。
    b> 删除操作
       首先查找B树中需删除的元素,如果该元素在B树中存在，则将该元素在其结点中进行删除，如果删除该元素后，首先判断该元素是否有左右孩子结点，
       如果有，则上移孩子结点中的某相近元素(“左孩子最右边的节点”或“右孩子最左边的节点”)到父节点中，然后是移动之后的情况；
       如果没有，直接删除后，移动之后的情况。
       
       删除元素，移动相应元素之后，如果某结点中元素数目（即关键字数）小于d和2d之间数目，则需要看其某相邻兄弟结点是否丰满（结点中元素个数大于d到2之间的数目）;
       如果丰满，则向父节点借一个元素来满足条件；
       如果其相邻兄弟都刚脱贫，即借了之后其结点数目小于d和2d之间数目，则该结点与其相邻的某一兄弟结点进行“合并”成一个结点，以此来满足条件。
    c> 查询
       

2.B+树
